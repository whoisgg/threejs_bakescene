"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDeclaredFunction = exports.findGlobalScope = exports.newOverloadIndex = exports.functionUseSignature = exports.findOverloadDefinition = exports.doSignaturesMatch = exports.functionDeclarationSignature = exports.quantifiersSignature = exports.extractConstant = exports.findBindingScope = exports.isDeclaredType = exports.findTypeScope = exports.makeScopeIndex = exports.UNKNOWN_TYPE = void 0;
var utils_1 = require("./utils");
exports.UNKNOWN_TYPE = 'UNKNOWN TYPE';
var makeScopeIndex = function (firstReference, declaration) { return ({
    declaration: declaration,
    references: [firstReference],
}); };
exports.makeScopeIndex = makeScopeIndex;
var findTypeScope = function (scope, typeName) {
    if (!scope) {
        return null;
    }
    if (typeName in scope.types) {
        return scope;
    }
    return (0, exports.findTypeScope)(scope.parent, typeName);
};
exports.findTypeScope = findTypeScope;
var isDeclaredType = function (scope, typeName) {
    return (0, exports.findTypeScope)(scope, typeName) !== null;
};
exports.isDeclaredType = isDeclaredType;
var findBindingScope = function (scope, name) {
    if (!scope) {
        return null;
    }
    if (name in scope.bindings) {
        return scope;
    }
    return (0, exports.findBindingScope)(scope.parent, name);
};
exports.findBindingScope = findBindingScope;
var extractConstant = function (expression) {
    var result = exports.UNKNOWN_TYPE;
    // Keyword case, like float
    if ('token' in expression) {
        result = expression.token;
        // User defined type
    }
    else if ('identifier' in expression &&
        typeof expression.identifier === 'string') {
        result = expression.identifier;
    }
    else {
        console.warn(result, expression);
    }
    return result;
};
exports.extractConstant = extractConstant;
var quantifiersSignature = function (quantifier) {
    return quantifier.map(function (q) { return "[".concat((0, exports.extractConstant)(q.expression), "]"); }).join('');
};
exports.quantifiersSignature = quantifiersSignature;
var functionDeclarationSignature = function (node) {
    var _a;
    var proto = node.type === 'function' ? node.prototype : node;
    var specifier = proto.header.returnType.specifier;
    var quantifiers = specifier.quantifier || [];
    var parameterTypes = ((_a = proto === null || proto === void 0 ? void 0 : proto.parameters) === null || _a === void 0 ? void 0 : _a.map(function (_a) {
        var specifier = _a.specifier, quantifier = _a.quantifier;
        // todo: saving place on putting quantifiers here
        var quantifiers = 
        // vec4[1][2] param
        specifier.quantifier ||
            // vec4 param[1][3]
            quantifier ||
            [];
        return "".concat((0, exports.extractConstant)(specifier.specifier)).concat((0, exports.quantifiersSignature)(quantifiers));
    })) || ['void'];
    var returnType = "".concat(specifier.specifier.token).concat((0, exports.quantifiersSignature)(quantifiers));
    return [
        returnType,
        parameterTypes,
        "".concat(returnType, ": ").concat(parameterTypes.join(', ')),
    ];
};
exports.functionDeclarationSignature = functionDeclarationSignature;
var doSignaturesMatch = function (definitionSignature, definition, callSignature) {
    if (definitionSignature === callSignature[0]) {
        return true;
    }
    var left = __spreadArray([definition.returnType], definition.parameterTypes, true);
    var right = __spreadArray([callSignature[0]], callSignature[1], true);
    // Special case. When comparing "a()" to "a(1)", a() has paramater VOID, and
    // a(1) has type UNKNOWN. This will pass as true in the final check of this
    // function, even though it's not.
    if (left.length === 2 && (0, utils_1.xor)(left[1] === 'void', right[1] === 'void')) {
        return false;
    }
    return (left.length === right.length &&
        left.every(function (type, index) {
            return type === right[index] ||
                type === exports.UNKNOWN_TYPE ||
                right[index] === exports.UNKNOWN_TYPE;
        }));
};
exports.doSignaturesMatch = doSignaturesMatch;
var findOverloadDefinition = function (signature, index) {
    return Object.entries(index).reduce(function (found, _a) {
        var overloadSignature = _a[0], overloadDefinition = _a[1];
        return (found ||
            ((0, exports.doSignaturesMatch)(overloadSignature, overloadDefinition, signature)
                ? overloadDefinition
                : undefined));
    }, undefined);
};
exports.findOverloadDefinition = findOverloadDefinition;
var functionUseSignature = function (node) {
    var parameterTypes = node.args.length === 0
        ? ['void']
        : node.args
            .filter(function (arg) { return arg.literal !== ','; })
            .map(function () { return exports.UNKNOWN_TYPE; });
    var returnType = exports.UNKNOWN_TYPE;
    return [
        returnType,
        parameterTypes,
        "".concat(returnType, ": ").concat(parameterTypes.join(', ')),
    ];
};
exports.functionUseSignature = functionUseSignature;
var newOverloadIndex = function (returnType, parameterTypes, firstReference, declaration) { return ({
    returnType: returnType,
    parameterTypes: parameterTypes,
    declaration: declaration,
    references: [firstReference],
}); };
exports.newOverloadIndex = newOverloadIndex;
var findGlobalScope = function (scope) {
    return scope.parent ? (0, exports.findGlobalScope)(scope.parent) : scope;
};
exports.findGlobalScope = findGlobalScope;
var isDeclaredFunction = function (scope, fnName) {
    return fnName in (0, exports.findGlobalScope)(scope).functions;
};
exports.isDeclaredFunction = isDeclaredFunction;
